/**
 * Real Malware Detection Engine
 * Implements multi-layered detection with signatures, heuristics, and behavioral analysis
 */

const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');

class MalwareDetectionEngine {
  constructor() {
    this.signatures = null;
    this.initialized = false;
    this.signaturePath = path.join(__dirname, 'virus-signatures.json');
    this.detectionCache = new Map();
  }

  /**
   * Initialize the detection engine
   */
  async initialize() {
    if (this.initialized) return;

    try {
      const data = await fs.readFile(this.signaturePath, 'utf8');
      this.signatures = JSON.parse(data);
      this.initialized = true;
      console.log('✅ Malware Detection Engine initialized');
      console.log(`   Signatures loaded: ${this.getSignatureCount()}`);
    } catch (error) {
      console.error('❌ Failed to load virus signatures:', error);
      // Create default signature file if missing
      await this.createDefaultSignatures();
    }
  }

  /**
   * Get total signature count
   */
  getSignatureCount() {
    if (!this.signatures) return 0;
    return (this.signatures.signatures.md5?.length || 0) +
           (this.signatures.signatures.sha256?.length || 0) +
           (this.signatures.signatures.patterns?.length || 0) +
           (this.signatures.signatures.yara_rules?.length || 0);
  }

  /**
   * Scan file for malware
   */
  async scanFile(filePath) {
    await this.initialize();

    const results = {
      filePath,
      isClean: true,
      threats: [],
      scanTime: Date.now(),
      detectionMethods: []
    };

    try {
      // Check cache first
      const fileHash = await this.calculateFileHash(filePath, 'sha256');
      const cached = this.detectionCache.get(fileHash);
      if (cached && Date.now() - cached.timestamp < 3600000) { // 1 hour cache
        return cached.result;
      }

      // 1. Hash-based detection (fastest)
      const hashDetection = await this.hashBasedDetection(filePath);
      if (hashDetection.detected) {
        results.isClean = false;
        results.threats.push(...hashDetection.threats);
        results.detectionMethods.push('hash-signature');
      }

      // 2. Pattern-based detection
      const patternDetection = await this.patternBasedDetection(filePath);
      if (patternDetection.detected) {
        results.isClean = false;
        results.threats.push(...patternDetection.threats);
        results.detectionMethods.push('pattern-matching');
      }

      // 3. Heuristic analysis
      const heuristicDetection = await this.heuristicAnalysis(filePath);
      if (heuristicDetection.detected) {
        results.isClean = false;
        results.threats.push(...heuristicDetection.threats);
        results.detectionMethods.push('heuristic');
      }

      // 4. Behavioral analysis (if suspicious)
      if (!results.isClean) {
        const behavioralDetection = await this.behavioralAnalysis(filePath);
        if (behavioralDetection.detected) {
          results.threats.push(...behavioralDetection.threats);
          results.detectionMethods.push('behavioral');
        }
      }

      // Cache result
      this.detectionCache.set(fileHash, {
        result: results,
        timestamp: Date.now()
      });

      // Limit cache size
      if (this.detectionCache.size > 1000) {
        const firstKey = this.detectionCache.keys().next().value;
        this.detectionCache.delete(firstKey);
      }

      return results;

    } catch (error) {
      console.error('Scan error:', error);
      throw error;
    }
  }

  /**
   * Hash-based detection
   */
  async hashBasedDetection(filePath) {
    const result = { detected: false, threats: [] };

    try {
      const md5 = await this.calculateFileHash(filePath, 'md5');
      const sha256 = await this.calculateFileHash(filePath, 'sha256');

      // Check MD5 signatures
      const md5Match = this.signatures.signatures.md5?.find(sig => sig.hash === md5);
      if (md5Match) {
        result.detected = true;
        result.threats.push({
          name: md5Match.name,
          type: md5Match.type,
          severity: md5Match.severity,
          family: md5Match.family,
          description: md5Match.description,
          method: 'MD5 signature',
          confidence: 100
        });
      }

      // Check SHA256 signatures
      const sha256Match = this.signatures.signatures.sha256?.find(sig => sig.hash === sha256);
      if (sha256Match) {
        result.detected = true;
        result.threats.push({
          name: sha256Match.name,
          type: sha256Match.type,
          severity: sha256Match.severity,
          family: sha256Match.family,
          description: sha256Match.description,
          method: 'SHA256 signature',
          confidence: 100
        });
      }

    } catch (error) {
      console.error('Hash detection error:', error);
    }

    return result;
  }

  /**
   * Pattern-based detection
   */
  async patternBasedDetection(filePath) {
    const result = { detected: false, threats: [] };

    try {
      const stats = await fs.stat(filePath);
      
      // Only scan text-based files or executables under 10MB
      if (stats.size > 10 * 1024 * 1024) {
        return result;
      }

      const content = await fs.readFile(filePath);
      const contentStr = content.toString('utf8', 0, Math.min(content.length, 1024 * 1024)); // First 1MB

      for (const pattern of this.signatures.signatures.patterns || []) {
        try {
          const regex = new RegExp(pattern.pattern, 'gm');
          if (regex.test(contentStr)) {
            result.detected = true;
            result.threats.push({
              name: pattern.name,
              type: pattern.type,
              severity: pattern.severity,
              description: pattern.description,
              method: 'Pattern matching',
              confidence: 85
            });
          }
        } catch (regexError) {
          console.warn('Invalid regex pattern:', pattern.pattern);
        }
      }

    } catch (error) {
      console.error('Pattern detection error:', error);
    }

    return result;
  }

  /**
   * Heuristic analysis
   */
  async heuristicAnalysis(filePath) {
    const result = { detected: false, threats: [] };

    try {
      const stats = await fs.stat(filePath);
      const ext = path.extname(filePath).toLowerCase();
      const fileName = path.basename(filePath);
      
      let suspicionScore = 0;
      const indicators = [];

      // Check file extension
      const dangerousExts = ['.exe', '.dll', '.scr', '.vbs', '.bat', '.cmd', '.ps1', '.js', '.jar', '.msi'];
      if (dangerousExts.includes(ext)) {
        suspicionScore += 20;
        indicators.push('Executable file type');
      }

      // Check for double extension
      if (/\.[a-z]{2,4}\.[a-z]{2,4}$/i.test(fileName)) {
        suspicionScore += 30;
        indicators.push('Double extension detected');
      }

      // Check file size anomalies
      if (stats.size < 1024 && dangerousExts.includes(ext)) {
        suspicionScore += 25;
        indicators.push('Unusually small executable');
      }

      // Check for suspicious naming patterns
      const suspiciousNames = /crack|keygen|patch|activator|loader|inject|hack/i;
      if (suspiciousNames.test(fileName)) {
        suspicionScore += 40;
        indicators.push('Suspicious filename pattern');
      }

      // Read file entropy (high entropy = likely packed/encrypted)
      if (stats.size < 5 * 1024 * 1024) {
        const entropy = await this.calculateEntropy(filePath);
        if (entropy > 7.5) {
          suspicionScore += 30;
          indicators.push(`High entropy (${entropy.toFixed(2)}) - possibly packed`);
        }
      }

      // Check PE headers for executables
      if (['.exe', '.dll'].includes(ext)) {
        const peAnalysis = await this.analyzePEHeader(filePath);
        if (peAnalysis.suspicious) {
          suspicionScore += peAnalysis.score;
          indicators.push(...peAnalysis.indicators);
        }
      }

      // Detection threshold
      if (suspicionScore >= 50) {
        result.detected = true;
        result.threats.push({
          name: 'Heuristic.Suspicious',
          type: suspicionScore >= 80 ? 'MALWARE' : 'SUSPICIOUS',
          severity: suspicionScore >= 80 ? 'high' : 'medium',
          description: `Heuristic analysis detected suspicious behavior (score: ${suspicionScore}/100)`,
          indicators,
          method: 'Heuristic analysis',
          confidence: Math.min(suspicionScore, 95)
        });
      }

    } catch (error) {
      console.error('Heuristic analysis error:', error);
    }

    return result;
  }

  /**
   * Behavioral analysis
   */
  async behavioralAnalysis(filePath) {
    const result = { detected: false, threats: [] };

    try {
      // Analyze file operations
      const content = await fs.readFile(filePath);
      const contentStr = content.toString('utf8', 0, Math.min(content.length, 512 * 1024));

      const behaviors = {
        networkActivity: /socket|connect|send|recv|http|https|ftp/gi.test(contentStr),
        registryAccess: /regkey|hkey|currentversion|run|runonce/gi.test(contentStr),
        processInjection: /createremotethread|virtualallocex|writeprocessmemory/gi.test(contentStr),
        fileEncryption: /encrypt|aes|rsa|cipher|ransom/gi.test(contentStr),
        antiDebug: /isdebuggerpresent|checkremotedebugger|ntqueryinformationprocess/gi.test(contentStr),
        privilegeEscalation: /runas|admin|elevate|uac/gi.test(contentStr)
      };

      let behaviorScore = 0;
      const detectedBehaviors = [];

      if (behaviors.networkActivity && behaviors.processInjection) {
        behaviorScore += 50;
        detectedBehaviors.push('Network activity + Process injection');
      }

      if (behaviors.fileEncryption) {
        behaviorScore += 40;
        detectedBehaviors.push('File encryption capabilities');
      }

      if (behaviors.antiDebug) {
        behaviorScore += 30;
        detectedBehaviors.push('Anti-debugging techniques');
      }

      if (behaviors.registryAccess && behaviors.privilegeEscalation) {
        behaviorScore += 35;
        detectedBehaviors.push('Registry modification + Privilege escalation');
      }

      if (behaviorScore >= 40) {
        result.detected = true;
        result.threats.push({
          name: 'Behavioral.Malicious',
          type: 'MALWARE',
          severity: behaviorScore >= 70 ? 'critical' : 'high',
          description: `Malicious behavioral patterns detected (score: ${behaviorScore}/100)`,
          behaviors: detectedBehaviors,
          method: 'Behavioral analysis',
          confidence: Math.min(behaviorScore + 10, 95)
        });
      }

    } catch (error) {
      console.error('Behavioral analysis error:', error);
    }

    return result;
  }

  /**
   * Calculate file entropy
   */
  async calculateEntropy(filePath) {
    try {
      const content = await fs.readFile(filePath);
      const freq = new Array(256).fill(0);
      
      for (let i = 0; i < content.length; i++) {
        freq[content[i]]++;
      }

      let entropy = 0;
      for (let i = 0; i < 256; i++) {
        if (freq[i] > 0) {
          const p = freq[i] / content.length;
          entropy -= p * Math.log2(p);
        }
      }

      return entropy;
    } catch (error) {
      return 0;
    }
  }

  /**
   * Analyze PE header (Windows executables)
   */
  async analyzePEHeader(filePath) {
    const result = { suspicious: false, score: 0, indicators: [] };

    try {
      const buffer = await fs.readFile(filePath);
      
      // Check for MZ header
      if (buffer[0] !== 0x4D || buffer[1] !== 0x5A) {
        result.suspicious = true;
        result.score += 50;
        result.indicators.push('Invalid PE header');
        return result;
      }

      // Check for unusual section names
      const content = buffer.toString('utf8');
      const suspiciousSections = /\.text|\.data|\.rdata|\.rsrc/gi;
      if (!suspiciousSections.test(content)) {
        result.suspicious = true;
        result.score += 20;
        result.indicators.push('Non-standard PE sections');
      }

      // Check for UPX packing
      if (/UPX[0-9]/i.test(content)) {
        result.suspicious = true;
        result.score += 25;
        result.indicators.push('UPX packed executable');
      }

    } catch (error) {
      console.error('PE analysis error:', error);
    }

    return result;
  }

  /**
   * Calculate file hash
   */
  async calculateFileHash(filePath, algorithm = 'sha256') {
    try {
      const content = await fs.readFile(filePath);
      return crypto.createHash(algorithm).update(content).digest('hex');
    } catch (error) {
      throw new Error(`Failed to calculate ${algorithm} hash: ${error.message}`);
    }
  }

  /**
   * Create default signatures
   */
  async createDefaultSignatures() {
    const defaultSignatures = {
      version: '1.0.0',
      lastUpdated: new Date().toISOString(),
      signatures: {
        md5: [],
        sha256: [],
        patterns: [],
        yara_rules: [],
        behavioral: []
      },
      whitelist: {
        processes: [],
        paths: [],
        hashes: []
      }
    };

    await fs.writeFile(this.signaturePath, JSON.stringify(defaultSignatures, null, 2));
    this.signatures = defaultSignatures;
  }

  /**
   * Update signatures from online source
   */
  async updateSignatures(newSignatures) {
    this.signatures = newSignatures;
    await fs.writeFile(this.signaturePath, JSON.stringify(newSignatures, null, 2));
    console.log('✅ Virus signatures updated');
  }
}

module.exports = new MalwareDetectionEngine();
